### 1、字面量和变量

#### 1.1、 字面量

- 都是一些不可改变的值，都是可以直接使用的，但是我们不会直接使用字面量

#### 1.2、 变量

- 可以用来保存字面量，而且变量的值是可以任意改变的

- 变量更加方便我们使用，所有在开发中都是通过变量去保存一个字面量，而很少直接使用字面量可以通过变量对字面量进行描述

#### 1.3、 声明变量

- 在 `JS` 中使用 `var` 关键字来声明一个变量
  `var a;`
- 如果声明的变量没有赋值而直接会直接输出 =>`'undefined'`,对于没有声明的变量直接使用浏览器会直接报错误信息警告
  为变量赋值
  `a=111111;`
- 声明和赋值同时进行
  `var b = 15615616;`

### 2、标识符

#### 2.1、在 `JS` 中所有的可以由我们自主命名的都可以称为标识符

- 例如：变量名、函数名、属性名都属于标识符

#### 2.2、命名一个标识符时要遵守如下的规则：

- 2.2.1.标识符中可以含有字母、数字、下划线`_`、`$`
- 2.2.2.标识符不能以数字开头
- 2.2.3.标识符不能是 ES 中的关键字或者保留字
- 2.2.4.标识符一般都采用驼峰命名法
  首字母小写，每个单词的开头字母大写，其余字母小写
  `JS` 底层保存标识符时实际上是采用 Unicode 编码，所以理论上讲，所有 utf-8 中含有的内容都可以作为标识符

### 3、数据类型

数据类型指的是字面量的类型

#### 3.1、`JS` 总一共有六种数据类型

- `String` 字符串
- `Number` 数值
- `Boolean` 布尔值
- `Null` 空值
- `Undefined` 未定义
- `Object` 对象
- 其中 `String、Number、Boolean、Null、Undefined` 属于基本数据类型，而 `Object` 属于引用数据类型
  可以使用 `typeof`类检查的类型
  语法：`typeof`变量
  检查对应的变量类型会返回对应字符串的类型名称

#### 3.2、String 字符串

- 在 `JS` 中字符串需要使用引号引起来
  例：var `str = 'xxxxx'`或`"xxxxx"` -使用双引号或者单引号都可以，但是不要混着用
- 引号不能嵌套，双引号不能放双引号，单引号不能放单引号
- 在字符串中我们可以使用\作为转义字符，当表示一些特殊符号时可以使用、进行转义

#### 3.3、Number 数值

- 在 `JS` 中所有的数值都是 Number 类型
  包括整数浮点数（小数）
- `JS` 中可以表示的数字最大值
  `Number.MAX_VALUE：1.7976931348623157e+308`
- 如果使用 Number 表示的数字超过了最大值，则会返回一个 Infinity 表示正无穷
- `NAN` 是一个特殊的数字，表示 Not A Number
- `JS` 中可以表示的数字最小值 大于 0 的最小值
  `Number.MIN_VALUE：5e-324`
- 在 `JS` 中整数的运算基本可以保证精确
- 如果使用 `JS` 进行浮点数运算，可能得到一个不精确的结果
  所以千万不要使用 `JS` 进行对精确要求比较高的运算

#### 3.4、Boolean 布尔值

- 布尔值只有两个值真（true）或 假（false）主要用来做逻辑判断

#### 3.5、Null 空值

- Null 类型的值就只有一个值，就是 Null
- Null 这个值专门用来表示一个为空的对象
- 使用 `typeof`检查一个 null 值时，就会返回 Object

#### 3.6、Undefined 未定义

- 当声明一个变量，但是并不给变量赋值时，它的值就是 `undefined`
- 使用 `typeof`检查一个 `Undefined` 值时，就会返回 `Undefined`

### 4、强制类型转换

- 指将一个数据类型强制转换为其它的数据类型
- 类型转换主要指，将其它的数据类型，转换为 `String、Number/Boolean`

#### 4.1、将其它的数据类型转换为 String

- 方式一
  - 调用被转换数据类型的 toString()方法
    例：调用`xxx`的`yyy()`方法，就是`xxx.yyy()`;
  - 该方法不会影响到原变量，它会将转换的结果返回
  - 但是要注意:`null` 和 `undefined` 这两个值没有 `toString` 方法
    如果调用它们的方法，会报错
- 方式二
  - 调用 `String()`函数，并将被转换的数据作为参数传递给函数
  - 使用 `String()`函数进行强制转换时
    对于 `Number` 和 `Boolean` 实际上就是调用 `toString()`方法
    但是对于 `null` 和 `undefined`，就不会调用 `toString()`方法
    它会将 `null` 直接转换成`'null'`
    将 `undefined` 直接转换成`'undefined'`

#### 4.2、将其它的数据类型转换为 Number

- 方式一
  - 使用 `Number` 函数
  - 字符串转数字 1.如果是纯数字的字符串，则直接将其转为数字 2.如果字符串有非数字的内容，则转换为 `NaN` 3.如果字符串是一个空串或者全是空格的字符串会转换为 0
  - 布尔值转数字
    `true` 转换成 1
    `false` 转换成 0
  - `null` 转数字是 0
  - `undefined` 转数字是 `NaN`
- 方式二
  - 这种方式专门用来对付字符串
  - `parseInt()`把一个字符串转换为一个整数
    可以将一个字符串中有效的整数内容转换出来
    如果对非 String 使用 `parseInt()`或 `parseFloat()`它会先将其转换为 String，然后再操作
    可以在 `parseInt()`中传递第二个参数 2,8,10，来指定数字的进制
  - `parseFloat()`把一个字符串转换为一个浮点数
    和 `parseInt()`作用类似，不同的是它可以获得有效的小数
    将其它的数据类型转换为 `Boolean`
    方式一（使用 `Boolean()`函数）

#### 4.3、数字转 Boolean

- 方式一（使用 `Boolean()`函数）

  - 除了 0 和`NaN`是 false，其余的都是 true

  - 字符串转 `Boolean` 除了空串是 `false`，其余的都是 `true`

  - `null` 和 `undefined` 都是转换为 `false`

  - 对象也会转换为 `true`

- 方式二（隐式类型转换）
  - 为任意的数据类型做两次非运算，即可将其转换为布尔值
    例：`var a= 'hello' a =!!a;//true`

#### 4.4、例：

```javaScript
var num1=123;
        num1.toString();
        //要想得到结果要这样使用
        num1= num1.toString();
        console.log(typeof num1);//number=>还是number=>string
        console.log(num1);//123=>123=>'123'

   /*     var num2 =null;
        num2= num2.toString();
        console.log(typeof num2);//报错
        console.log(num2);//报错

        var num3 =undefined;
        num3= num3.toString();
        console.log(typeof num3);//报错
        console.log(num3);//报错*/

        //调用String()函数，来讲变量转换成字符串
        var num4 =123;
        num4= String(num4);
        num4=null;
        num4= String(num4);
        num4=undefined;
        num4= String(num4);
        console.log(typeof num4);//string
        console.log(num4);//'123'=>'null'=>'undefined'

        //将其它的数据类型转换为Number
        var num5='abc';
        num5='';
        num5=true;
        num5=null;
        num5=undefined;
        num5=Number(num5);
        num5='123px';
        num5=parseInt(num5);
        num5=parseFloat(num5);
        console.log(typeof num5);//string=>number
        console.log(num5);//'123'=>123
        //将其它的数据类型转换为Boolean
        var num6 = 123;//true
        num6=-123;//true
        num6=0;//false
        num6=Infinity;//true
        num6=NaN;//false
        num6='';//false
        num6=null;//false
        num6=undefined;//false
        num6=Boolean(num6);
        console.log(typeof num6);//string=>number
        console.log(num6);//'123'=>123
```

### 5、其它进制的数字

- 在 JS 中，如果需要表示 16 进制的数字，则需要以 0x 开头

  - 如果需要表示 8 进制的数字，则需要以 0 开头
  - 如果需要表示 2 进制的数字，则需要以 0b 开头
  - 但并不是所有浏览器支持
  - 例：

  ```javaScript
   //16进制
     var a = 0x10;//16
   //8进制
     a=070;//56
   //2进制
     a=0b00;//0
  ```

### 6、算术运算符

- 运算符也叫操作符
  - 通过运算符可以对一个或者多个值进行运算，并获取运算结果
  - 比如 `typeof` 就是运算符，可以获得一个值的类型
    它会将该值的类型以字符串的形式返回：`number string boolean undefined object`
- 算术运算符
  - 当对非 `Number` 类型的值进行运算时，会将这些值转换为 `Number` 然后再运算
    任何值和 `NaN` 运算都得 `NaN`
  - 任何值做`- * /`运算时都会自动转换为 `Number`
    可以利用这一特点做隐式的类型转换
    可以通过为一个值`-0 *1 /1`来将其转换为 `Number`
    原理和 `Number()`函数一样，使用起来更加简单

#### 6.1、+（加法运算符）

- 可以对两个值进行加法运算，并将结果返回
- 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回
- 任何值和字符串做加法运算，都会先转换为字符串，然后再和字符串进行拼串的操作
  - 我们可以利用这一特点，来将一个任意的数据类型转换成 `String`
  - 我们只需要为任意的数据类型`+`一个`""`即可将其转换为 `String`
  - 这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用 `String()`函数

#### 6.2、-（减法运算符）

- 可以对两个值进行减法运算，并将结果返回

#### 6.3、\*（乘法运算符）

- 可以对两个值进行乘法运算，并将结果返回

#### 6.4、/（除法运算符）

- 可以对两个值进行除法运算，并将结果返回

#### 6.5、%（求余运算符）

- 可以对两个值进行取模运算（取余数），并将结果返回

### 7、一元运算符

#### 7.1、一元运算符，只需要一个操作数

- - 正号
  * 正号不会对数字产生任何影响
- 负号
  - 负号可以对数字进行负号取反
  - 对于非 `Number`类型的值
    它会先转换为 `Number`类型，然后再运算
    可以对一个其它的数据类型使用+，来将其转换成 `number`
    它的原理和`Number()`函数一样

### 8、自增自减

#### 8.1、自增 ++

- 通过自增可以使变量在自身的基础增加 1

- 对于一个变量自增以后，原变量的值会立即自增 1

- 自增分成两种：后++（a++）和前++（++a）
  无论是 a++还是++a，都会立即使原变量的值自增 1
  不同的是 a++和++a 的值不同
  a++的值等于原变量的值（自增前的值）
  ++a 的值等于新值（自增后的值）

- 例：

  ```javascript
  var a = 1;
  a++;
  console.log(a); //2
  var b = 1;
  var c = b++;
  console.log(c); //1
  console.log(b); //2

  var d = 20;
  var result = d++ + ++d + d; // d++ => 20 ++d=>22 d => 22
  console.log(result); // 64

  var n1 = 10,
    n2;
  n2 = n1++;
  console.log(n2); //10
  console.log(n1); //11
  ```

#### 8.2、自减 --

- 通过自减可以使变量在自身的基础上减 1
- 自减分成两种：后--（a--）和前--（--a）
  无论是 a-- 还是 --a 都会立即使原变量的值自减 1
  不同的是 a--和--a 的值不同
  a--的值等于原变量的值（自减前的值）
  --a 的值等于新值（自减后的值）

### 9、逻辑运算符

JS 中为我们提供了三种逻辑运算符

#### 9.1、！非

- `！`可以用来对一个值进行非运算
- 所谓非运算就是对一个布尔值进行取反操作
  `true` 变 `false` `false` 变 `true`
- 如果对一个值进行两次取反，它不会变化
- 如果对非布尔值进行取反，则会将其转换为布尔值，然后再取反
  所以我们可以利用该特点，来将一个其它的数据类型转换为布尔值
  可以为一个任意数据类型取两次反，来将其转换为布尔值，原理和 `Boolean()`函数一样

#### 9.2、&& 与

- `&&`可以对符号两侧的值进行与运算并返回结果
- 运算规则
  - 两个值中只要一个值为 `false` 就返回 `false`
    只有两个值都为 `true` 时，才会返回 `true`
  - Js 中的“与”属于短路的与，如果第一个值为 `false`，则不会判断第二个值了

#### 9.3、|| 或

- `||`可以对符号两侧的值进行或运算并返回结果
- 运算规则

  - 两个值中只要有一个 `true`，就返回 `true`
    如果两个值都为 `false`，就返回 `false`
  - `JS` 中的“或”属于短路的或，如果第一个值为 `true`，则不会判断第二个值

#### 9.4、&&(与) ||(或) 非布尔值的情况

- 对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值
- 与运算：
  如果两个值都为 `true`，则必然返回第二个的值
  如果两个值有 `false`，则直接返回第一个值
- 或运算：
  如果第一个值为 `true`，则直接返回第一个值
  如果第一个值为 `false`，则返回第二个值

### 10、赋值运算符

`=`可以将符号右侧的值赋值给符号左侧的变量

```javascript
 	  +=
      a+= 5等价于a=a+5
      -=
      a-= 5等价于a=a-5
      *=
      a*= 5等价于a=a*5
      /=
      a/= 5等价于a=a/5
      %=
      a%= 5等价于a=a%5
```

### 11、关系运算符

通过关系运算符可以比较两个值之间的大小
如果关系成立它会返回 `true`，如果关系不成立则返回 `false`

#### 11.1、>大于号

- 判断符号左侧的值是否大于右侧的值
- 如果关系成立，返回 `true`，如果关系不成立则返回 `false`
- `> =`大于或等于
  `>`判断符号左侧的值是否大于或者等于右侧的值

#### 11.2、<小于号

- `<=`小于或等于

#### 11.3、==相等运算符

- 用来比较两个值是否相等，如果相等会返回 `true`，否则返回 `false`
- 当使用`==`来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型再进行比较
- `undefined` 衍生至 `null`
  所以这两个值做相等时，会返回 `true`
- `NaN` 不和任何值相等，包括它本身
  可以通过 `isNaN()`函数来判断一个值是否是 `NaN`

#### 11.4、!=不相等运算符

- 不相等用来判断两个值是否不相等，如果不相等返回 `true`，否则返回 `false`
- 不相等也会对变量进行自动的类型转换，如果转换后相等它会返回 `false`

#### 11.5、===全等

- 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动类型转换
  如果两个值的类型不同直接返回 `false`

#### 11.6、！==不全等

- 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动类型转换
  如果两个值的类型不同，直接返回 `true`

- 非数值的情况
  - 对于非数值进行比较时，会将其转换为数字再进行比较
    如果比较的两个字符串型的数字，可能会得到不可预期的结果
    注意：在比较两个字符串型的数字时，一定一定一定要转型
  - 任何值和 `NaN` 比较都是 `false`
  - 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较而会分别比较字符串中字符的 `Unicode` 编码
    比较字符编码时是一位一位进行比较，如果两位一样，则比较下一位，所以借用它来对英文进行排序
    比较中文没有意义

#### 11.7、Unicode 编码

- 在字符串中使用转义字符输入 `Unicode` 编码
  `\u` 四位编码
- 在网页中使用 `Unicode` 编码
  &#编码; 这里的编码需要的是 10 进制

### 12、条件运算符

- 条件运算符也叫三元运算符

  - 语法：
    条件表达式?语句 1:语句 2
    例：
    `var a =10,b=20 a>b?a:b`
  - 执行过程
    条件运算符执行时，首先对条件表达式进行求值
    如果该值为 `true`，则执行语句 1，并返回执行结果
    如果该值为 `false`，则执行语句 2，并返回执行结果
    如果条件表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算
  - ,运算符

    - 使用,可以分割多个语句，一般可以在声明变量时使用
      例：
      `var a=1,b=2,c=3;`

    - 运算符的优先级
      就和数学中一样，在 JS 中运算符也有优先级，比如先乘除后加减
      在 JS 中有一个运算符优先级的表，在表上越靠上越高级，优先级越高越优先计算，
      如果优先级一样，则从左往右计算，如果想要改变优先级可以在代码中加()或者[],
      来改变优先级

### 13、流程控制语句

- JS 中的程序是从上到下一行一行执行的
- 通过流程控制语句可以控制程序执行流程
  使程序可以根据一定的条件来选择执行
- 语句的分类 1.条件判断语句 2.条件分支语句 3.循环语句

#### 13.1、条件判断语句

- 使用条件判断语句可以在执行某个语句之前进行判断
  如果条件成立才会进行执行，条件不成立语句不执行
- `if` 语句
- 语法一：

```javascript
  if（条件表达式）{
  语句...
  }
```

`if` 语句在执行时，会对条件表达式进行求值判断
如果条件表达式的值为 `true`，则执行 `if` 后的语句，
如果条件表达式的值为 `false`，则不会执行 `if` 后的语句
`if` 语句只能控制紧随其后的那个语句，
如果希望 `if` 语句可以控制多条语句，
可以将这些语句统一放到代码块中
`if` 语句后的代码块不是必须的，但是在开发中尽量写代码块，即使 `if` 后只有一条语句

- 语法二

```javascript
  if（条件表达式）{
  语句...
  }else{
  语句...
  }
```

`if...else...`语句
当该语句执行时，会先对 `if` 后的条件表达式进行求值判断,
如果该值为 `true`，则执行 `if` 后的语句，如果该值为 `false`，则执行 `else` 后的语句

- 语法三

```javascript
  if（条件表达式）{
  语句...
  }else if（条件表达式）{
  语句...
  }else if（条件表达式）{
  语句...
  }else{
  语句...
  }
```

当该语句执行时，会从上到下依次对条件表达式进行求值判断
如果值为 `true`，则执行当前语句
如果值为 `false`，则继续向下判断
如果条件都不满足，则执行最后一个 `else` 后的语句
该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句

- 例：

```javascript
var value = prompt("请输入成绩：");
if (parseFloat(value).toString() == "NaN") {
  console.log(typeof value);
  console.log("语句1  " + value);
} else {
  console.log(typeof value);
  console.log("语句2  " + value);
}
```

#### 13.2、条件分支语句也叫 switch 语句

- 语法：

  ```javascript
  switch（条件表达式）{
  case 表达式：
  语句...
  break;
  case 表达式：
  语句...
  break;
  default:
  语句...
  break;
  }
  ```

- 执行流程：

  - `switch...case...`语句
  - 在执行时会一次将 `case` 后的表达式的值和 switch 后的条件表达式的值进行全等比较
  - 如果比较结果为 `true`，则从当前 `case` 处开始执行代码
    当前 `case` 后的所有的代码都会执行，可以在 `case` 的后边跟着一个 `break` 关键字
    这样可以确保只会执行当前 `case` 后的语句，而不会执行其它的 `case`
  - 如果比较结果为 `false`，则继续向下比较
  - 如果所有的比较结果为 `false`，则执行 `default` 后的语句

- `switch` 语句和 `if` 语句的功能实际上有重复的，使用 `switch` 可以实现 `if` 的功能
  同样 `if` 也可以实现 `switch` 的功能，所以我们使用时，可以根据自己的习惯选择

#### 13.4、循环语句

- 通过循环语句可以反复的执行一段代码多次
- `while` 循环
  语法：
  `while（条件表达式）{ 语句... }`
- `while` 语句在执行时
  先对条件表达式进行求值判断，如果值为 `true`，则执行循环体
  循环体执行完毕以后，继续对表达式进行判断
  如果为 `true`，则继续执行循环体，以此类推
  如果值为 `false`，则终止循环·
- 创建一个 `while` 循环，往往需要三个步骤 1.创建一个初始化变量 2.在循环中设置一个条件表达式 3.定义一个更新表达式，每次更新初始化变量
- 例：

```javascript
var num = 1000;
var index = 0;
while (num < 5000) {
  num *= 1.05;
  index++;
}
console.log(index, "  " + num);
```

- `do...while` 循环
  - 语法：
    `do{ 语句... }while（条件表达式）`
- 执行流程：
  - `do...while` 语句在执行时，会先执行循环体，
  - 循环体执行完毕以后，再对 `while` 后的条件表达式进行判断
  - 如果结果为 `true`，则继续执行循环体，执行完毕继续判断以此类推
  - 如果结果为 `false`，则终止循环
- 区别：
  实际上值两个语句功能类似，不同的是 `while` 是先判断后执行
  而 `do...while` 会先执行后判断，可以保证循环体至少执行一次，而 `while` 不能
- `for` 语句，也是一个循环语句，也称为 `for` 循环

  - 在 `for` 循环中，为我们提供了专门的位置用来放三个表达式 1.初始化表达式 2.条件表达式 3.更新表达式
  - 语法：
    `for（① 初始化表达式;③ 条件表达式;④ 更新表达式）{ ③ 语句... }`
  - for 循环的执行过程
    ① 执行初始化表达式，初始化变量（初始化表达式只执行一次）
    ② 执行条件表达式，判断是否执行循环
    如果为 `true`，则执行循环 ③
    如果为 `false`，则终止执行
    ④ 执行更新表达式，更新表达式执行完毕继续重复 ②

  - 嵌套的 `for` 循环
    - `break` 关键字可以用来退出 `switch` 或循环语句
      不能在 `if` 语句中使用 `break` 和 `continue`
      `break` 关键字，会立刻终止离它最近的那个循环语句
      在嵌套循环的过程中想要停止最外层循环可以为循环语句创建一个 label，
      label：循环语句
      使用 `break` 关键字时，可以在 `break` 后跟着一个 label
      这样 `break` 将会结束指定的循环，而不是最近的
    - `continue` 关键字可以用来跳过当次循环
      同样 `continue` 也是默认只会对离它最近的循环起作用
      label：循环语句
      使用 `continue` 关键字时，可以在 `continue` 后跟着一个 label
      这样 `continue` 将会结束指定的循环，而不是最近的

#### 13.5、例：

```javascript
//水仙花数
for (var i = 100; i < 1000; i++) {
  var bai = parseInt(i / 100);
  var shi = parseInt((i % 100) / 10);
  var ge = parseInt((i % 100) % 10);
  if (bai * bai * bai + shi * shi * shi + ge * ge * ge == i) {
    console.log(i);
  }
}
// 质数
var num = prompt("请输入一个大于1的整数：");
if (num <= 1) {
  alert("该值不合法！");
} else {
  var flag = true;
  for (var i = 2; i < num; i++) {
    if (num % i == 0) {
      flag = false;
    }
  }
}
if (flag) {
  alert("该值是质数");
} else {
  alert("该值不是质数");
}
//九九乘法表
for (var i = 1; i <= 9; i++) {
  for (var j = 1; j <= 9; j++) {
    document.write(i + "*" + j + "=" + i * j + "&nbsp;");
    if (i == j) {
      document.write("<br/>");
      break;
    }
  }
}
```

### 14、对象

Object 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性

#### 14.1、对象的分类

- 1.内建对象
  由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用
  比如：`Math、String、Number、Boolean、Function、object.....`
- 2.宿主对象
  由 `JS` 的运行环境提供的对象，目前来讲主要由浏览器提供的对象
  比如 `BOM DOM`
- 3.自定义对象
  由开发人员创建的对象
- 使用 new 关键字调用的函数，是构造函数 `constructor`
  - 构造函数是专门用来创建对象的函数
  - 在对象中保存的值称为属性
  - 向对象添加属性
    对象的属性名不强制要求遵守标识符的规范，
    什么乱七八糟的名字都可以用，
    但是我们使用时还是尽量按照标准的规范去做
    如果使用特殊的属性名，不能采用.的方式来操作，
    需要用另一种方式，语法：对象['属性名'] = 属性值
    读取时也需要采用这种方式,
    使用[]这种形式去操作属性，更加灵活，
    在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性
    语法：对象.属性名=属性值；
  - 读取对象中的属性
    语法;对象.属性名
  - 如果读取对象中没有的属性，不会报错而是会返回 `undefined`
  - 修改对象的属性值
    语法：对象.属性名=新值；
  - 删除对象的属性
    语法：`delete` 对象.属性名
  - 属性值
    - JS 对象的属性值，可以是任意的数据类型
      甚至也可以是一个对象
    - `in` 运算符
      - 通过该运算符可以检查一个对象中是否含有指定的属性
        如果有则返回 `true`，没有则返回 `false`
      - 语法："属性名" `in` 对象

#### 14.2、浅析基本数据类型和引用数据类型在内存中的位置

- 基本数据类型
  `String Number Boolean Null Undefined`
- 引用数据类型
  `Object`
- JS 中的变量都是保存到栈内存中的
- 基本数据类型的值直接在栈内存中存储
- 值与值直接是独立存在，修改一个变量不会影响其它的变量
- 对象是保存到堆内存，每创建一个新的对象，就会在堆内存中开辟出一个新的空间
- 而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用
- 当一个通过一个变量修改属性时，另一个也会受到影响
- 比较两个基本数据类型的值时，就是比较值
- 当两个对象进行比较时比较的是对象在内存中引用的内存地址
  如果两个对象一模一样的，但是地址不同，它会返回 `false`

#### 14.3、对象字面量

`var obj = {}`

- 使用对象字面量时，可以在创建对象时，直接指定对象中的属性
  - 语法：{属性名：属性值，属性名：属性值...}
  - 对象字面量的属性名可以加引号也可以不加，建议不加，
  - 如果使用一些特殊的名字，则必须加引号
  - 属性名和属性值是一组一组的名值对结构
    名和值之间使用：连接，多个名值对之间使用，隔开
    如果一个属性之后没有其它属性了，就不要写，
- 方法（函数作为对象的属性保存，我们就称为这个函数是这个对象的方法）

- 枚举对象中的属性（使用 `for...in` 语句）
  - 语法：
    `for（var 变量 in 对象）{}`
  - `for...in` 语句对象中有几个属性，循环体就会执行几次
    每次执行时，会将对象中的一个属性的名字赋值给变量

#### 14.4、使用工厂方法创建对象

- 通过该方法可以大批量的创建对象
- 使用工厂方法创建的对象，使用的构造函数都是 `Object`
- 所有创建的对象都是 `Object` 这个类型
- 就导致我们无法区分出多种不同类型的对象

#### 14.5、构造函数

- 构造函数就是一个普通函数，创建方式和普通函数没有区别
- 不同的是构造函数首字母大写
- 构造函数和普通函数的区别就是调用方式的不同
  普通函数就是直接调用，而构造函数需要使用 `new` 关键字来调用
- 构造函数的执行流程
  - 1.立刻创建一个新的对象
  - 2.将新建的对象设置为函数中的 `this`,在构造函数中可以使用 `this` 来引用新建的对象
  - 3.逐行执行函数中的代码
  - 4.将新建的对象作为返回值返回
- 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。
  - 我们将通过一个构造函数创建的对象，称为是该类的实例
  - 使用 `instanceof` 可以检查一个对象是否是一个类的实例
    - 语法：
      对象 `instanceof` 构造函数
      如果是，则返回 `true`，否则返回 `false`
  - 所有的对象都是 `Object` 的后代
    所以任何对象和 `Object` 做 `instanceof` 检查时都会返回 `true`

#### 14.6、this 的情况

- 1.当以函数的形式调用时，`this` 指向 `window`
- 2.当以方法的形式调用时，谁调用方法 `this` 就是谁
- 3.当以构造函数的形式调用时，`this` 就是新创建的那个对象

#### 14.7、原型 prototype

- 我们所创建的每一个函数，解析器都会向函数中添加一个属性 `prototype`
  这个属性对应着一个对象，这个对象就是我们所谓的原型对象
- 如果函数作为普通函数调用 `prototype` 没有任何作用
- 当函数以构造函数形式调用时，它所创建的对象都会有一个隐含的属性
  指向该构造函数的原型对象，可以通过`__proto__`来访问该属性
- 原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象
  我们可以将对象中共有的内容，统一设置到原型对象中
- 当我们访问对象的一个属性或方法，它会先找在对象自身中寻找，如果有则直接使用，
  如果没有则会去原型对象中寻找，如果找到则直接使用
- 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中
  这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了
- 原型对象也是对象，所以它也有原型，
  - 当我们使用一个对象的属性或方法时，会先在自身中寻找
    自身如果有，则直接使用，
    如果没有则去原型对象中寻找，如果原型对象中有，则使用，
    如果没有则去原型的原型中寻找,直到找到 `Object` 对象的原型，
    `Object` 对象的原型没有原型，如果在 `Object` 中依然没有找到，则返回 `undefined`

#### 14.8、例：

```javascript
//创建一个对象
// var obj =new Object();
//向对象添加属性和属性
// obj.name = 'dengchang';
//修改对象属性的属性值
// obj.name = 'testdata';
//删除对象的属性
// delete obj.name;

// var obj1 = new Object();
// obj1.var = 'testdata';
//特殊属性名
// obj1['123']='testdata';
// var n = '123';
// console.log(obj1[n]);

//枚举对象的属性
/* var obj = {
             name:'dengchang',
             age:18
         };*/
/*for (var n in obj){
            // console.log('属性'+n);
            // console.log(obj[n]);
        }
*/
//使用工厂方法创建对象
/*  function person1(name,age,gender) {
              var obj = new Object();
              obj.name=name;
              obj.age=age;
              obj.gender=gender;
              obj.sayName = function () {
                  console.log(this.name);
              };
              return obj
          }*/
// var obj2 = person1('dengchang',23,'男')
// obj2.sayName();
// console.log(obj2);
//构造函数
/*   function Person(name,age,gender) {
               this.name = name;
               this.age= age;
               this.gender=gender;
               this.sayName = function () {
                   console.log(this.name);
               };
           }*/
/*function Dog() {

        }*/
//普通函数调用
// var per1 = Person('dengchang',18,'男');
// console.log(per1);
//构造函数调用
// var per2 = new Person('dengchang',18,'男');
// per2.sayName();
// console.log(per2);
// var dog = new Dog();
// console.log(per2 instanceof Person);

//构造函数修改版
/**
 * 创建一个Person构造函数
 *  -在Person构造函数中，为每一个对象都添加了一个sayName方法，
 *      目前我们的方法是在构造函数内部创建的
 *          也就是构造函数每执行一次就好创建一个新的sayName方法
 *          也就是所有实例的sayName都是唯一的。
 *      这样就导致了构造函数执行一次就好创建一个新的方法
 *          执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的
 *          这是完全没有必要，完全可以使所有的对象共享同一个方法
 */
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  // this.sayName = fun;
}
//将sayName方法在全局作用域中定义
/**
 *将函数定义在全局作用域中，污染了全局作用域的命名空间
 * 而且定义在全局作用域中也不安全
 */
Person.prototype.sayName = function () {
  console.log(this.name);
};
/*  function fun() {
              console.log(this.name);
          }*/
var per = new Person("dengchang", 18, "男");
var per2 = new Person("dengchang2", 18, "男");
per.sayName();
per2.sayName();
// console.log(per.sayName==per2.sayName);

//原型对象
function Preson1() {}

function Myclass() {}
Myclass.prototype.a = "原型的a";
var mc = new Myclass();
mc.a = "我是mc的a";
// console.log(Preson1.prototype==Myclass.prototype);
// console.log(mc.__proto__==Myclass.prototype);
// console.log(mc.a);
//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
// console.log('a' in mc);
//可以使用对象的hasOwnProperty(对象名.hasOwnProperty('属性名'))来检查对象自身中是否含有该属性
//使用该方法只有当对象自身含有属性时，才会返回true
// console.log(mc.hasOwnProperty('a'));
// console.log(mc.hasOwnProperty('hasOwnProperty'));
// console.log(mc.__proto__.hasOwnProperty('hasOwnProperty'));
// console.log(mc.__proto__.__proto__.hasOwnProperty('hasOwnProperty'));//true
```
